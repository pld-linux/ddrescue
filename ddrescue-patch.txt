Only in .: arg_parser.o
Only in .: block.o
Only in .: ddrescue
diff -u ../ddrescue-1.2/ddrescue.cc ./ddrescue.cc
--- ../ddrescue-1.2/ddrescue.cc	2006-03-16 19:14:05.000000000 +0100
+++ ./ddrescue.cc	2006-08-14 16:48:54.000000000 +0200
@@ -28,6 +28,7 @@
 #include <queue>
 #include <signal.h>
 #include <unistd.h>
+#include <inttypes.h>
 
 #include "ddrescue.h"
 
@@ -190,19 +191,20 @@
   }
 
 
-void show_status( const long long ipos, const long long opos,
+void show_status( std::vector< Sblock > & sblock_vector,
+                  const long long ipos, const long long opos,
                   const long long recsize, const long long errsize,
-                  const int errors, const char * msg, bool force ) throw()
+                  const int errors, const char * msg, bool force, int hardbs ) throw()
   {
   static const char * const up = "\x1b[A";
   static long long a_rate = 0, c_rate = 0, first_size = 0, last_size = 0;
   static long long last_ipos = 0, last_opos = 0;
   static time_t t0 = 0, t1 = 0;
   static int oldlen = 0;
+  static int first= 1;
   if( t0 == 0 )
     {
     t0 = t1 = std::time( 0 ); first_size = last_size = recsize; force = true;
-    std::printf( "\n\n\n" );
     }
 
   if( ipos >= 0 ) last_ipos = ipos;
@@ -216,7 +218,59 @@
       c_rate = ( recsize - last_size ) / ( t2 - t1 );
       t1 = t2; last_size = recsize;
       }
-    std::printf( "\r%s%s%s", up, up, up );
+    if(!first)
+      std::printf( "\r%s%s%s", up, up, up );
+    if(width && height)
+      {
+      int cell_count= width*height;
+      int64_t block_count=sblock_vector[sblock_vector.size()-1].end() / hardbs;
+
+      cell_count= block_count / ((block_count + cell_count - 1) / cell_count);
+
+      if(!first)
+        for(int i=0; i<cell_count; i+= width)
+          std::printf(up);
+
+      int j=0;
+      for(int i=0; i<cell_count; i++)
+        {
+        int64_t start=  i   *hardbs*block_count / cell_count;
+        int64_t end  = (i+1)*hardbs*block_count / cell_count;
+        int non_tried=0;
+        int bad=0;
+        int ok=0;
+        for(; j<sblock_vector.size() && sblock_vector[j].end() <= start; j++);
+        for(; j<sblock_vector.size() && sblock_vector[j].pos() < end; j++)
+          {
+          Sblock & sb = sblock_vector[j];
+          int size= (std::min(end, (int64_t)sb.end()) - std::max(start, (int64_t)sb.pos()) ) / hardbs;
+          switch( sb.status() )
+            {
+            case Sblock::non_tried  : non_tried+= size; break;
+            case Sblock::non_split  :
+            case Sblock::bad_block  : bad      += size; break;
+            case Sblock::done       : ok       += size; break;
+            }
+          }
+        j--;
+
+        if(opos*(int64_t)cell_count / (hardbs*block_count) == i)
+          std::printf("\x1b[05;04m");
+
+        if(non_tried)         std::printf("?");
+        else if( !bad &&  ok) std::printf(" ");
+        else if(  bad && !ok) std::printf("\x1b[01;31mX");
+        else if( !bad && !ok) std::printf("!");
+        else if(  bad > 3*ok) std::printf("\x1b[31mx");
+        else if(  bad >   ok) std::printf("\x1b[01;33m+");
+        else if(3*bad >   ok) std::printf("\x1b[33m-");
+        else                  std::printf("\x1b[32m.");
+        std::printf("\x1b[00m");
+
+        if(i%width == width - 1 || i+1 == cell_count)
+            std::printf("\n");
+        }
+      }
     std::printf( "rescued: %10sB,", format_num( recsize ) );
     std::printf( "  errsize:%9sB,", format_num( errsize, 99999 ) );
     std::printf( "  current rate: %9sB/s\n", format_num( c_rate, 99999 ) );
@@ -231,4 +285,5 @@
     oldlen = len;
     std::fflush( stdout );
     }
+    first=0;
   }
Only in .: ddrescue.cc~
diff -u ../ddrescue-1.2/ddrescue.h ./ddrescue.h
--- ../ddrescue-1.2/ddrescue.h	2006-03-29 18:29:46.000000000 +0200
+++ ./ddrescue.h	2006-08-06 09:18:41.000000000 +0200
@@ -105,15 +105,18 @@
   int do_rescue( const int ides, const int odes ) throw();
   };
 
+extern int width ;
+extern int height;
 
 // Defined in ddrescue.cc
 //
 const char * format_num( long long num, long long max = 999999,
                          const int set_prefix = 0 ) throw();
 void set_handler() throw();
-void show_status( const long long ipos, const long long opos,
+void show_status( std::vector< Sblock > & sblock_vector,
+                  const long long ipos, const long long opos,
                   const long long recsize, const long long errsize,
-                  const int errors, const char * msg = 0, bool force = false ) throw();
+                  const int errors, const char * msg = 0, bool force = false, int hardbs = 512 ) throw();
 
 
 // Defined in main.cc
Only in .: ddrescue.h~
Only in .: ddrescue.o
Common subdirectories: ../ddrescue-1.2/doc and ./doc
diff -u ../ddrescue-1.2/logbook.cc ./logbook.cc
--- ../ddrescue-1.2/logbook.cc	2006-04-03 12:52:39.000000000 +0200
+++ ./logbook.cc	2006-08-06 09:16:37.000000000 +0200
@@ -300,8 +300,8 @@
         }
       if( _verbosity >= 0 )
         {
-        show_status( chip.pos(), chip.pos() + _offset, recsize, errsize, errors,
-                     "Copying data...", first_post ); first_post = false;
+        show_status( sblock_vector, chip.pos(), chip.pos() + _offset, recsize, errsize, errors,
+                     "Copying data...", first_post, _hardbs ); first_post = false;
         }
       std::vector< Sblock > result;
       int retval = copy_non_tried_block( chip, result );
@@ -354,8 +354,8 @@
         }
       if( _verbosity >= 0 )
         {
-        show_status( chip.pos(), chip.pos() + _offset, recsize, errsize, errors,
-                     "Splitting error areas...", first_post ); first_post = false;
+        show_status( sblock_vector, chip.pos(), chip.pos() + _offset, recsize, errsize, errors,
+                     "Splitting error areas...", first_post, _hardbs ); first_post = false;
         }
       std::vector< Sblock > result;
       int retval = copy_bad_block( chip, result );
@@ -413,8 +413,8 @@
             }
           if( _verbosity >= 0 )
             {
-            show_status( chip.pos(), chip.pos() + _offset, recsize, errsize, errors,
-                         msgbuf, first_post ); first_post = false;
+            show_status( sblock_vector, chip.pos(), chip.pos() + _offset, recsize, errsize, errors,
+                         msgbuf, first_post, _hardbs ); first_post = false;
             }
           std::vector< Sblock > result;
           int retval = copy_bad_block( chip, result );
@@ -532,7 +532,7 @@
     if( retval < 0 ) { msg = "Interrupted by user"; retval = 0; }
     else if( _max_errors >= 0 && errors > _max_errors )
       msg = "Too many errors in input file";
-    show_status( -1, -1, recsize, errsize, errors, msg, true );
+    show_status( sblock_vector, -1, -1, recsize, errsize, errors, msg, true, _hardbs );
     std::fputc( '\n', stdout );
     }
   compact_sblock_vector( sblock_vector );
Only in .: logbook.cc~
Only in .: logbook.o
diff -u ../ddrescue-1.2/main.cc ./main.cc
--- ../ddrescue-1.2/main.cc	2006-04-03 12:48:36.000000000 +0200
+++ ./main.cc	2006-08-14 16:26:51.000000000 +0200
@@ -39,6 +39,9 @@
 #include "ddrescue.h"
 
 
+int width = 0;
+int height= 0;
+
 namespace {
 
 // Date of this version: 2006-04-03
@@ -72,6 +75,8 @@
   std::printf( "  -s, --max-size=<bytes>       maximum size of data to be copied\n" );
   std::printf( "  -t, --truncate               truncate output file\n" );
   std::printf( "  -v, --verbose                verbose operation\n" );
+  std::printf( "  -W, --width                  ascii art width\n" );
+  std::printf( "  -H, --height                 ascii art height\n" );
   std::printf( "Numbers may be followed by a multiplier: b = blocks, k = kB = 10^3 = 1000,\n" );
   std::printf( "Ki = KiB = 2^10 = 1024, M = 10^6, Mi = 2^20, G = 10^9, Gi = 2^30, etc...\n" );
   std::printf( "\nReport bugs to bug-ddrescue@gnu.org\n");
@@ -203,6 +208,8 @@
     { 't', "truncate",        Arg_parser::no  },
     { 'v', "verbose",         Arg_parser::no  },
     { 'V', "version",         Arg_parser::no  },
+    { 'W', "width",           Arg_parser::yes },
+    { 'H', "height",          Arg_parser::yes },
     {  0 , 0,                 Arg_parser::no  } };
 
   Arg_parser parser( argc, argv, options );
@@ -231,6 +238,8 @@
       case 's': max_size = getnum( arg, hardbs, -1 ); break;
       case 't': o_trunc = O_TRUNC; break;
       case 'v': verbosity = 1; break;
+      case 'W': width  = getnum( arg, 0, 1, INT_MAX ); break;
+      case 'H': height = getnum( arg, 0, 1, INT_MAX ); break;
       case 'V': show_version(); return 0;
       default : internal_error( "uncaught option" );
       }
Only in .: main.cc~
Only in .: main.cc.orig
Only in .: main.o
Only in .: Makefile
